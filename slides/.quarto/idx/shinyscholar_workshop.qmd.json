{"title":"Shinyscholar","markdown":{"yaml":{"title":"Shinyscholar","subtitle":"A template for creating reproducible Shiny applications","author":"Simon Smart","format":{"revealjs":{"logo":"images/uol_logo.png","code-line-numbers":false,"theme":["default","custom.scss"],"chalkboard":true,"width":1600,"height":900,"scale":true,"slide-number":true}},"date":"7 June 2025","date-format":"long","preload-iframes":false},"headingText":"Overview","containsRefs":false,"markdown":"\n\n\n-   Use of Shiny in academia\n-   How Shinyscholar helps to avoid common problems\n-   How to use `create_template()` to make an app\n-   How to develop modules\n\n::: {.fragment .fade-in}\n-   Please ask questions!\n:::\n\n## About me\n\n-   Background in plant sciences and agricultural science\n-   Software developer in the Department of Population Health Sciences at the University of Leicester with Tim Lucas\n-   Latecomer to R, starting in 2018\n-   Quickly fell in love with Shiny\n\n## {data-menu-title=\"About you\"}\n```{=html}\n<iframe width=\"100%\" height=\"100%\" src =\"https://wall.sli.do/event/hHaXgfyR5WUSp5R33BzT5W/?section=fd94117a-f537-4081-91a2-4ca9266d4e32\"></iframe>\n```\n\n## Tomvision\n<img src=\"images/tomvision.png\" class=\"centre_image\" >\n\n## Potato Yield Model Dashboard\n\n![](images/PYM_home.png)\n\n## Disagapp simplifies disaggregation regression [https://disagapp.le.ac.uk/](https://disagapp.le.ac.uk/)\n\n<img src=\"images/disagapp.png\" class=\"centre_image\" >\n\n## Shiny apps are becoming increasingly popular in academia\n\n::: columns\n::: {.column width=\"55%\"}\n-   The low barrier to entry makes Shiny popular\n-   Substantially increased apps as a method of dissemination\n-   \"shiny app\" or \"shiny application\" in Web of Science:\n:::\n\n::: {.column width=\"45%\"}\n```{r echo = FALSE, fig.height=10}\nyear <- c(2012, 2015:2023) \napps <- c(1, 4, 3, 12, 17, 39, 69, 75, 100, 134)\nmod <- lm(log(apps) ~ year)\n\npar(cex = 1.5, bg = '#e4fbf8')\nplot(year, apps, pch = 16, xlab = '', ylab = 'Number of publications')\nlines(seq(2012, 2023, 0.1), exp(predict(mod, data.frame(year = seq(2012, 2023, 0.1)))), col = 'blue')\n\n```\n:::\n:::\n\n::: {.notes}\n-   Easier to develop than using other web frameworks\n- Existing code can be adapted\n:::\n\n## The ease of development provides advantages and disadvantages\n\n-   Simple apps can be created in an afternoon\n-   Academics rarely have training in software development\n-   What started simple can quickly snowball to become very complex\n\n## Data flows through an analysis in discrete steps \n\n<img src=\"images/data_pipeline.svg\" class=\"centre_image\" >\n \n::: footer\n- Adapted from <a href=\"https://r4ds.hadley.nz/intro\" target=\"_blank\">Wickham (2022)</a>\n:::\n \n::: {.notes}\n-   Analytical apps have a flow of data through them\n-   Similar to an analysis, but we are providing options for the user to take their own particular path\n-   Distinguish between datavis apps and analysis apps\n:::\n\n## What characteristics should academic apps have?\n\n::: columns\n::: {.column width=\"50%\"}\n::: {.fragment .fade-in}\n-   Open\n:::\n::: {.fragment .fade-in}\n-   Attributable\n:::\n::: {.fragment .fade-in}\n-   Instructive\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n-   Reproducible\n:::\n::: {.fragment .fade-in}\n-   Reliable\n:::\n::: {.fragment .fade-in}\n-   Maintainable\n:::\n:::\n:::\n\n::: {.notes}\n- We are all familiar with the format and conventions of papers, but they weren't always like that. Should we aim to develop similar conventions for apps?\n\n- Open enables reuse and collaboration\n- Important to recognise developers of the software like authors of a paper\n- Users should be guided through inside of the application, not through watching videos or reading a guide \n- Analyses performed in the app should be reproducible outside of it\n- We should be confident that it functions as intended through the use of automated testing\n- Contracts are short, so it is important people unfamiliar with the code can understand what is happening.\n\n:::\n\n## There are many ways to structure shiny apps\n\n::: columns\n::: {.column width=\"20%\"}\n:::\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_1.svg)\n:::\n:::\n:::\n\n## There are many ways to structure shiny apps\n![](images/ROGUE_input.png)\n![](images/ROGUE_output.png)\n\n## There are many ways to structure shiny apps\n::: columns\n::: {.column width=\"20%\"}\n:::\n::: {.column width=\"15%\"}\n![](images/app_arch_1.svg)\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_2.svg)\n:::\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_3.svg)\n:::\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_4.svg)\n:::\n:::\n:::\n\n## 50 apps published in 2023 were surveyed to determine current practices\n\n<img src=\"images/app_features.svg\" class=\"centre_image\" >\n\n::: {.notes}\n- Caveat: not all were analytical applications\n- i.e. whilst best practice, they are not used due to the difficulty of implementation\n:::\n\n## The size and structure of codebases varied substantially\n<img src=\"images/code_features.svg\" class=\"centre_image\" >\n\n## Other frameworks exist for making production quality shiny apps\n\n- `{rhino}` by Appsilon: dashboard-focused\n- `{golem}` by ThinkR: good but generic\n- `{teal}` by Insight Engineering / Roche: pharma-focused\n\n## `{shinymeta}` can also be used to create reproducible apps\n\n- Developed by Posit\n- Requires a lot of refactoring / unusual syntax\n- Unclear if it's suited to large apps\n\n```{r eval = FALSE, echo = TRUE }\nserver <- function(input, output) {\n  var <- metaReactive({\n    cars[[..(input$var)]]\n  })\n  output$Summary <- metaRender(renderPrint, {\n    summary(..(var()))\n  })\n  output$code <- renderPrint({\n    expandChain(output$Summary())\n  })\n}\n```\n\n## Wallace is an app for modelling species distributions\n<img src=\"images/wallace.png\" class=\"centre_image\" >\n\n## Wallace is an app for modelling species distributions\n\n-   In development since 2015 with two major releases\n-   Feature-rich with many ideal characteristics:\n\n::: columns\n::: {.column width=\"50%\"}\n-   Error messages\n-   Logging\n-   Save and load\n:::\n::: {.column width=\"50%\"}\n-   Reproducible\n-   Cites packages used\n:::\n:::\n\n::: footer\n- Kass *et al.* (2018) <a href=\"https://doi.org/10.1111/2041-210X.12945\" target=\"_blank\">DOI: 10.1111/2041-210X.12945</a>\n- Kass *et al.* (2022) <a href=\"https://doi.org/10.1111/ecog.06547\" target=\"_blank\">DOI: 10.1111/ecog.06547</a>\n:::\n\n## Wallace provided the foundation to create shinyscholar\n\n-  Lots of useful features that are difficult to implement from scratch\n-  Removed all the modules\n-  Adapted files so they could be edited programmatically\n\n## Various new features have been added since {.mediumtext}\n\n- Updated UI\n- Viewing source code\n- Running async tasks\n- End-to-end testing with {shinytest2}\n- Simplified reproducibility\n- Long-term reproducibility via {renv}\n- Automated tedious coding\n\n## Installation\n\n- `install.packages(\"shinyscholar\")` installs all you need to create new apps\n- The package also includes an example app, which requires `install.packages(\"shinyscholar\", dependencies = TRUE)` to run\n\n## Shinyscholar enforces a strict structure\n\n-   Structured as a package\n-   Analyses are split into components and modules\n-   Each module calls a function\n-   Each module is reproduced by a markdown chunk\n-   Data is passed between modules through `common`\n\n## This structure has various advantages\n\n- Modules are self-contained\n- New modules slot in easily\n- Explicit for developers where code is located\n\n## Overview of the live demo\n\n- The package contains an example app\n- We'll create a similar app and copy some of the modules\n- Then we'll develop a new module and go through each of the steps to develop it\n\n## `create_template()` requires a dataframe of modules \n\n```{r eval = TRUE, echo = FALSE}\n\nmodules <- data.frame(\n  \"component\" = c(\"select\", \"select\", \"transform\", \"plot\", \"plot\"),\n  \"long_component\" = c(\"Select data\", \"Select data\", \"Transform data\", \"Plot data\", \"Plot data\"),\n  \"module\" = c(\"async\", \"query\", \"filter\", \"hist\", \"scatter\"),\n  \"long_module\" = c(\"Upload your own data\", \"Query a database to obtain data\", \"Filter the data\",\n                    \"Plot the data as a histogram\", \"Plot the data as a scatterplot\"),\n  \"map\" = c(TRUE, FALSE, TRUE, FALSE, FALSE),\n  \"result\" = c(FALSE, FALSE, TRUE, TRUE, TRUE),\n  \"rmd\" = c(TRUE, TRUE, TRUE, TRUE, TRUE),\n  \"save\" = c(TRUE, TRUE, TRUE, TRUE, TRUE),\n  \"download\" = c(FALSE, FALSE, TRUE, TRUE, TRUE),\n  \"async\" = c(TRUE, FALSE, FALSE, FALSE, FALSE))\n\n```\n\n```{r eval = TRUE, echo = FALSE}\nknitr::kable(modules, format = \"html\")\n```\n\n## Modules in disagapp\n<img src=\"images/disagg_modules_path.svg\" class=\"centre_image\" >\n\n## `common` is an object passed between modules \n\n- A shared environment for storing data\n- Avoids having to manually manage what data each module interacts with\n- Helps ensure consistent use of variable names\n- All set to `NULL` by default \n- `common$reset()` allows it to be reset\n\n## `common` in Disagapp {.smalltext}\n\n::: columns\n::: {.column width=\"33%\"}\n- `shape`\n- `response_name`\n- `agg`\n- `agg_prep`\n- `agg_prep_lores`\n- `covs`\n:::\n::: {.column width=\"33%\"}\n- `covs_prep`\n- `covs_prep_lores`\n- `covs_matrix`\n- `covs_summary`\n- `mesh`\n- `prep`\n:::\n::: {.column width=\"33%\"}\n- `fit`\n- `fit_plot`\n- `pred`\n- `transfer`\n- `map_layers`\n- `poly`\n:::\n:::\n\n\n## `create_template()` creates an empty app ðŸš€ {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\n\ncommon_objects = c(\"raster\", \"histogram\", \"scatter\")\n\nshinyscholar::create_template(\n  path = file.path(\"~\", \"Documents\"), name = \"SSdemo\", author = \"Simon Smart\",\n  include_map = TRUE, include_table = TRUE, include_code = TRUE, \n  common_objects = common_objects, modules = modules, install = TRUE)\n\nSSdemo::run_SSdemo()\n```\n\n\n## Structure of the app files\n\n```\nâ”œâ”€â”€ DESCRIPTION                                                 Define dependencies\nâ”œâ”€â”€ inst\nâ”‚   â””â”€â”€ shiny\nâ”‚       â”œâ”€â”€ common.R                                            Data objects shared between modules\nâ”‚       â”œâ”€â”€ global.R                                            Loads package and modules\nâ”‚       â”œâ”€â”€ ui_helpers.R                                        Functions to create module UI\nâ”‚       â”œâ”€â”€ server.R                                            App server\nâ”‚       â”œâ”€â”€ ui.R                                                App UI\nâ”‚       â”œâ”€â”€ modules\nâ”‚       â”‚   â”œâ”€â”€ core_code.R                                     Displays code\nâ”‚       â”‚   â”œâ”€â”€ core_intro.R                                    Produces introductory walkthrough\nâ”‚       â”‚   â”œâ”€â”€ core_load.R                                     Loads app\nâ”‚       â”‚   â”œâ”€â”€ core_mapping.R                                  Creates map\nâ”‚       â”‚   â”œâ”€â”€ core_save.R                                     Saves app\nâ”‚       â”‚   â”œâ”€â”€ select_async.md                                 Module guidance\nâ”‚       â”‚   â”œâ”€â”€ select_async.R                                  Module UI and server\nâ”‚       â”‚   â”œâ”€â”€ select_async.Rmd                                Reproduces the module\nâ”‚       â”‚   â”œâ”€â”€ select_async.yml                                Module configuration\nâ”‚       â”‚   â”œâ”€â”€ ... (repeated for other modules)\nâ”‚       â”œâ”€â”€ Rmd\nâ”‚       â”‚   â”œâ”€â”€ gtext_load.Rmd                                  Guidance text for each component\nâ”‚       â”‚   â”œâ”€â”€ gtext_plot.Rmd\nâ”‚       â”‚   â”œâ”€â”€ gtext_rep.Rmd\nâ”‚       â”‚   â”œâ”€â”€ references.Rmd                                  Template for rep_refPackages\nâ”‚       â”‚   â”œâ”€â”€ text_about.Rmd                                  Main panel on intro tab\nâ”‚       â”‚   â”œâ”€â”€ text_how_to_use.Rmd                             Detailed instructions\nâ”‚       â”‚   â”œâ”€â”€ text_intro_tab.Rmd                              Sidebar on intro tab\nâ”‚       â”‚   â”œâ”€â”€ text_loadsesh.Rmd                               Guidance for loading\nâ”‚       â”‚   â”œâ”€â”€ text_team.Rmd                                   Lists developers\nâ”‚       â”‚   â”œâ”€â”€ userReport_intro.Rmd                            Introduction to markdown\nâ”‚       â”‚   â””â”€â”€ userReport_module.Rmd\nâ”‚       â””â”€â”€ www\nâ”‚           â”œâ”€â”€ css\nâ”‚           â”‚   â””â”€â”€ styles.css\nâ”‚           â”œâ”€â”€ favicon.ico\nâ”‚           â”œâ”€â”€ js\nâ”‚           â”‚   â””â”€â”€ shinyjs-funcs.js\nâ”‚           â””â”€â”€ logo.png\nâ”œâ”€â”€ R\nâ”‚   â”œâ”€â”€ helper_functions.R                                      Various utility functions\nâ”‚   â”œâ”€â”€ run_demo.R                                              Function to run app\nâ”‚   â”œâ”€â”€ select_async_f.R                                        Function for each module\nâ”‚   â”œâ”€â”€ select_query_f.R\nâ”‚   â”œâ”€â”€ plot_histogram_f.R\nâ”‚   â””â”€â”€ plot_scatter_f.R\nâ””â”€â”€ tests\n    â””â”€â”€ testthat\n        â”œâ”€â”€ test-load_user.R                                    Tests for each module\n        â”œâ”€â”€ test-load_database.R\n        â”œâ”€â”€ test-plot_histogram.R\n        â””â”€â”€ test-plot_scatter.R\n\n```\n\n## Shiny modules split code into manageable chunks {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\nui <- fluidPage(\n  load_module_ui(\"load\"),\n  plot_module_ui(\"plot\")\n)\n\nserver <- function(input, output, session){\n  load_module_server(\"load\")\n  plot_module_server(\"plot\")\n}\n```\n\n## `input` and `output` IDs are *namespaced* {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\nnumericInput(\"number\") \nplotOutput(\"plot\") \n\nns <- NS(id)\nplotOutput(ns(\"plot\"))\nnumericInput(ns(\"number\"))\n```\n\n- When used inside a module with an id of `load`, `ns()` appends `load-` to the ID so `load-plot` and `load-number` are created\n\n## By default though there is a lot to manage:\n- Sourcing the functions\n- Calling the functions\n- Passing data between modules\n- Reactivity between modules\n\n::: {.fragment .fade-in}\n- Shinyscholar takes care of all of these!\n:::\n\n## Modules in shinyscholar have a broader definition and several files ðŸš€ {.verysmalltext}\n\n- In `R/`:\n    -   Function: `<component>_<module>_f.R`\n\n- In `inst/shiny/modules/`:\n    -   Shiny module: `<component>_<module>.R`\n    -   Rmarkdown: `<component>_<module>.Rmd`\n    -   Guidance: `<component>_<module>.md`\n    -   Configuration: `<component>_<module>.yml`\n\n- In `tests/:`\n    -   Tests: `test-<component>_<module>.R`\n\n## The logging system provides a flexible way to inform users {.mediumcode}\n\n- Messages can be sent to users via `common$logger |> writeLog()`\n- Either from inside the module function or the module server function\n\n```{r eval = FALSE, echo = TRUE}\nif (is.null(common$raster)) {\n  common$logger |> writeLog(type = \"error\", \"Please load a raster file\")\n  return()\n}\n```\n\n## The logging system provides a flexible way to inform users {.mediumtext}\n\n- When `type = \"info\" / \"warning\" / \"error\"` a `shinyalert::shinyalert()` modal is also displayed\n- `type = \"starting\" / \"complete\"` keep track of slow tasks\n- When `logger = NULL` inside a function, i.e. when used in the rmarkdown messages are passed to `message()`, `warning()` or `stop()` instead \n\n## Unusually, data is not reactive\n\n- Shiny is built to be reactive, but for large apps it can be difficult to control\n- Data in shinyscholar is not reactive \n- `{gargoyle}` is used instead to explicitly trigger reactivity\n\n## Gargoyle is used to trigger events\n\n- Each module's identifier can be used to trigger events\n- `init(<id>)` is called during app start up\n- `trigger(<id>)` is called when a module runs successfully\n- `watch(<id>)` is used inside any outputs to be generated / other code that needs to run\n\n## Module development workflow\n\n<img src=\"images/workflow.svg\" class=\"centre_image\" >\n\n## Data flow in shiny vs shinyscholar\n\n::: columns\n::: {.column width=\"50%\"}\n```{mermaid}\nflowchart TD\nA[Input in UI] --> |input$| B([Computation in server])\nB --> |output$| C(Output in UI)\n\nclass A sin\nclass B sser\nclass C sout\n```\n:::\n::: {.column width=\"50%\" .fragment .fade-in} \n```{mermaid}\nflowchart TD\nA[Input in UI] --> |input$| C([Functions])\nB[Existing data] --> |common$| C([Functions])\nC --> |common$| D([Store in common])\nD --> |output$| E(Output in Results)\n\nclass A sin\nclass B sin\nclass C sser\nclass D sser\nclass E sout\n```\n:::\n:::\n\n## Developing the module function\n\n- Functions split the business logic from the shiny logic and enable reproducibility\n- First of all develop the function in an rmarkdown file\n- Once it works, move it to the function file and document\n- Parameters should either be `common` objects or `input` values\n\n## Functions should be written defensively\n\n- Check that inputs are correct and log any errors\n- May be not always be necessary when used in the app but we're also creating user-facing functions used in the rmarkdown\n- Catch any other errors and fail gracefully instead of crashing the app\n\n## The `select_query()` function in the example app is most complex ðŸš€\n\n```{r echo=TRUE, eval=FALSE}\nselect_query <- function(poly, date, token, logger = NULL) {\n\n  check_suggests()\n\n  if (!(\"matrix\" %in% class(poly))){\n    logger |> writeLog(type = \"error\",\"poly must be a matrix\")\n    return()\n  }\n\n  if (!is.character(date) || is.na(as.Date(date, format = \"%Y-%m-%d\"))) {\n    logger |> writeLog(type = \"error\",\"date must be a string with the format YYYY-MM-DD\")\n    return()\n  }\n\n  if (nchar(token) < 200 || is.null(token)){\n    logger |> writeLog(type = \"error\", \"This function requires a NASA token - see the documentation\")\n    return()\n  }\n\n  # convert to terra object to calculate area and extent\n  terra_poly <- terra::vect(poly, crs = \"EPSG:4326\", type = \"polygons\")\n  area <- terra::expanse(terra_poly, unit = \"km\")\n  if (area > 1000000) {\n    logger |> writeLog(type = \"error\", paste0(\"Your selected area is too large (\",round(area,0),\" km2)\",\n                                              \" when the maximum is 1m km2. Please select a smaller area\"))\n    return()\n  }\n\n  bbox <- c(min(poly[,1]), max(poly[,2]), max(poly[,1]), min(poly[,2]))\n\n  search_url <- glue::glue(\"https://ladsweb.modaps.eosdis.nasa.gov/api/v2/content/archives?products=MCD15A2H&temporalRanges={date}&regions=[BBOX]W{bbox[1]}%20N{bbox[2]}%20E{bbox[3]}%20S{bbox[4]}&archiveSets=61\")\n  check <- check_url(search_url)\n\n  if (!is.null(check)){\n    image_req <- httr2::request(search_url ) |>\n                  httr2::req_auth_bearer_token(token) |>\n                  httr2::req_perform()\n\n    image_resp <- image_req |> httr2::resp_body_html()\n\n    image_links <- xml2::xml_find_all(image_resp, \"//a\")\n    image_urls <- xml2::xml_attr(image_links, \"href\")\n  } else {\n    logger |> writeLog(type = \"error\", \"The FAPAR API is currently offline\")\n    return()\n  }\n\n  # download and stitch together tiles\n  raster <- NULL\n  for (file in image_urls){\n    if (tools::file_ext(file) == \"hdf\"){\n      req <- httr2::request(file) |>\n        httr2::req_auth_bearer_token(token) |>\n        httr2::req_perform()\n\n      temp <- tempfile(fileext = \".hdf\")\n      writeBin(httr2::resp_body_raw(req), temp)\n\n      tile <- terra::rast(temp)$Fpar_500m\n      if (is.null(raster)){\n        raster <- tile\n      } else {\n        raster <- terra::merge(raster, tile)\n      }\n    }\n  }\n\n  if (is.null(raster)){\n    logger |> writeLog(type = \"error\", paste0(\"No data was found for your selected area. \",\n                                               \"This could be due to cloud coverage or because the area is not over land.\"))\n    return()\n  }\n\n  # reproject and crop\n  raster <- terra::project(raster, \"EPSG:4326\")\n  raster <- terra::crop(raster, terra_poly)\n\n  # count missing values and log accordingly\n  missing_values <- length(terra::values(raster)[terra::values(raster) > 1])\n  urban <- length(terra::values(raster)[terra::values(raster) == 2.5])\n  water <- length(terra::values(raster)[terra::values(raster) == 2.54])\n\n  if (missing_values == terra::ncell(raster)) {\n    logger |> writeLog(type = \"error\", paste0(\"No data was found for your selected area. \",\n                                               \"This could be due to cloud coverage or because the area is not over land.\"))\n    return()\n  }\n  if (missing_values > 0) {\n    message <- glue::glue(\"{missing_values} pixels were removed.\")\n    if (urban > 0) {\n      message <- paste(message, glue::glue(\"{urban} pixels were removed due to urban land use.\"), sep = \" \")\n    }\n    if (water > 0) {\n      message <- paste(message, glue::glue(\"{water} pixels were removed due to water coverage.\"), sep = \" \")\n    }\n    logger |> writeLog(message)\n  }\n\n  # remove missing values and rescale data to 0 - 100 %\n  raster <- terra::clamp(raster, upper = 1, value = FALSE) * 100\n\n  raster\n}\n```\n\n## Unit testing {.mediumcode} ðŸš€\n\n- Each module should have unit tests and end-to-end tests\n- Unit test tests that the module function behaves as you expect\n- End-to-end tests check that the whole module works\n\n```{r echo = TRUE, eval = FALSE}\ntest_that(\"Check select_user function works as expected\", {\n  result <- select_user()\n  expect_true(is.null(result))\n})\n```\n\n## The shiny module contains several functions {.mediumtext}\n\n- `<identifier>_module_ui()` - user inputs\n- `<identifier>_module_server()` - server function\n\n- Optionally:\n- `<identifier>_module_result()` - display outputs\n- `<identifier>_module_map()` - modify the map\n- `<identifier>_module_rmd()` - transfer data to rmarkdown\n\n## Only Input functions are included in the module UI {.mediumcode .mediumtext}\n\n- Input IDs need wrapping in `ns()`\n- Everything is wrapped in `tagList`\n\n```{r echo = TRUE, eval = FALSE}\nplot_hist_module_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    selectInput(ns(\"bins\"), \"Number of bins\", choices = c(10, 20, 50, 100)),\n    selectInput(ns(\"pal\"), \"Colour palette\", choices = c(\"Greens\", \"YlOrRd\", \"Greys\", \"Blues\")),\n    actionButton(ns(\"run\"), \"Plot histogram\")\n  )\n}\n```\n\n## Input widgets are inserted to the sidebar \n\n<img src=\"images/input_sidebar.png\" >\n\n## The server contains an `observeEvent()` triggered by `input$run` {.mediumtext .smallheader}\n\n- Inputs are checked and any errors logged\n- Inputs are passed to the module function \n- Input values are stored in `common$meta`\n- Module function is called and results stored in `common`\n- Use `trigger()` to run anything that relies on the results\n- Use `show_map()` or `show_results()` to change the view\n\n## The server contains an `observeEvent()` triggered by `input$run` {.mediumcode .smallheader}\n\n```{r echo = TRUE, eval = FALSE}\n  observeEvent(input$run, {\n    # WARNING ####\n    if (is.null(common$raster)) {\n      common$logger |> writeLog(type = \"error\", \"Please load a raster file\")\n      return()\n    }\n    # FUNCTION CALL ####\n    raster_name <- c(common$meta$select_query$name, common$meta$select_async$name, common$meta$select_user$name)\n    histogram <- plot_hist(common$raster, as.numeric(input$bins), input$pal, raster_name, common$logger)\n    # LOAD INTO COMMON ####\n    common$histogram <- histogram\n    # METADATA ####\n    common$meta$plot_hist$bins <- as.numeric(input$bins)\n    common$meta$plot_hist$pal <- input$pal\n    common$meta$plot_hist$name <- raster_name\n    # TRIGGER ####\n    trigger(\"plot_hist\")\n    show_results(parent_session)\n    shinyjs::show(\"download\")\n  })\n```\n\n## Outputs are triggered when the module runs successfully {.mediumcode}\n\n```{r echo = TRUE, eval = FALSE}\noutput$hist <- renderPlot({\n  watch(\"plot_hist\")\n  req(common$histogram)\n  common$histogram()\n  })\n```\n\n## Outputs are inserted into the results tab {.mediumcode} ðŸš€\n\n- The visible results are determined by the module currently selected\n\n```{r echo = TRUE, eval = FALSE}\nplot_hist_module_result <- function(id) {\n  ns <- NS(id)\n  plotOutput(ns(\"hist\"))\n}\n```\n\n## Saving and loading \n\n- When the app is saved, `common` is saved to an `.Rds` \n- Each module's input values are stored in `common$state`\n- Distinct from those stored in `common$meta` which are only for modules that have been run\n\n## Saving and loading\n\n- Loading reloads data into `common`\n- Input values are restored from `common$state`\n- Module outputs are retriggered from `names(common$meta)`\n\n## The ability to save is also helpful during development\n\n- If working on a feature that relies on results from a slow step, it can be tedious to rerun each time a change is made\n- We can load `common` in outside shiny and use the exact data used in the app\n- Set `load_file_path` to point to a save file and it will be loaded automatically \n\n## `save_and_load()` takes care of tedious coding {.mediumcode} ðŸš€\n\n- Currently only default `{shiny}` inputs are supported\n\n```{r echo = TRUE, eval = FALSE}\nsave_and_load(\".\") # for all modules\nsave_and_load(\".\", module = \"component_module\") # for a single module\n\nnumericInput(ns(\"number\"), \"Enter a number\", value = 5)\n\nlist(number = input$number) # save\nupdateNumericInput(session, \"number\", state$number) # load\n```\n\n## Markdown files can be merged to replicate the analysis\n\n-   When a module is used an object becomes `TRUE`\n-   Input values are stored and *knitted* into the markdown\n-   Each chunk of the markdown calls the same function as the module in the app\n-   The chunks for used modules are combined into one `.Rmd` file\n\n## Input values are copied into the rmarkdown {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\n#```{r, echo = {{select_query_knit}}, include = {{select_query_knit}}}\npoly <- {{select_query_poly}}\ntoken <- {{select_query_token}}\nras <- select_query(poly, {{select_query_date}}, token)\nraster_name <- {{select_query_name}}\n#```\n```\n\n## To create a reproducible chunk {.mediumcode} ðŸš€\n\n```{r eval = FALSE, echo = TRUE}\n#```{r}\npoly <- structure(c(-0.871582, -0.871582, 0.322266, 0.322266, -0.871582, \n                    42.136253, 43.421009, 43.421009, 42.136253, 42.136253), \n                  dim = c(5L, 2L), dimnames = list(    NULL, c(\"longitude\", \"latitude\")))\ntoken <- NULL\nraster <- select_query(poly, \"2024-10-09\", token)\nraster_name <- \"FAPAR\"\n#```\n```\n\n## You can also add data directly to the markdown {.mediumtext}\n\n- If the output of a module is a small dataframe (~ 1000 values) then you can insert the `common` object straight into the markdown\n- Especially useful if files are uploaded as that can't be reproduced automatically\n- Alternatively, download a `.zip` of data and load that in the markdown (example below)\n\n:::footer\n  - https://github.com/simon-smart88/disagapp/blob/main/inst/shiny/modules/rep_covs.R\n  - https://github.com/simon-smart88/disagapp/blob/main/inst/shiny/modules/rep_covs.Rmd\n  - https://github.com/simon-smart88/disagapp/blob/d7739ff034b2bf12760b54516a6d1f087e42b97c/inst/shiny/modules/rep_markdown.R#L77 \n\n:::\n\n## As for saving and loading, `metadata()` takes care of some of the tedium ðŸš€ {.mediumcode}\n\n- Unlike for `save_and_load()` this requires manual work afterwards and can therefore only be called once for each module\n\n```{r echo = TRUE, eval = FALSE}\nmetadata(\".\") # for all modules\nmetadata(\".\", module = \"component_module\") # for a single module\n\nnumericInput(ns(\"number\"), \"Enter a number\", value = 5)\n\ncommon$meta$component_module$number <- input$number # store\ncomponent_module_number <- common$meta$component_module$number # transfer to Rmd\n{{component_module_number}} # use in Rmd\n```\n\n## End-to-end tests ðŸš€ {.mediumcode}\n\n```{r echo = TRUE, eval = FALSE}\ntest_that(\"{shinytest2} recording: e2e_select_user\", {\n  app <- shinytest2::AppDriver$new(app_dir = system.file(\"shiny\", package = \"demo\"), name = \"e2e_select_user\")\n  app$set_inputs(tabs = \"select\")\n  app$set_inputs(selectSel = \"select_user\")\n  app$click(\"select_user-run\")\n  common <- app$get_value(export = \"common\")\n  expect_true(is.null(common$scatter))\n})\n```\n\n## Asynchronous modules\n\n- A major limitation of R and therefore Shiny is that it is single-threaded by default\n- When a slow operation is occurring apps become unresponsive to the user and anyone else connected to the same instance\n- `ExtendedTask` was added in Shiny v1.8.1 and enables tasks to run in the background\n\n## Slow running tasks can block the UI\n\n<div style=\"text-align: center;\">\n  <video style=\"width: 80%;\" loop muted data-autoplay>\n    <source src=\"images/async.webm\" type=\"video/webm\">\n  </video>\n</div>\n\n## Asynchronous modules\n\n- When `async = TRUE` for a module a different skeleton is used\n- The structure is different since starting the task and dealing with the results are separate\n- The number of currently running tasks is shown under the logger\n\n## The normal logger can't be accessed from inside async tasks {.mediumtext .mediumcode}\n \n- `asyncLog()` is similar to `writeLog()` but can be used inside async functions\n- Use `async = FALSE` as the last parameter instead of `logger = NULL` \n- `return(async %>% asyncLog(\"message))` sends errors back\n\n```{r  eval = FALSE, echo = TRUE}\n  if (!is.character(date) || is.na(as.Date(date, format = \"%Y-%m-%d\"))) {\n    return(async %>% asyncLog(type = \"error\", \"date must be a string with the format YYYY-MM-DD\"))\n  }\n```\n\n## We can listen for messages in the server and then pass to the logger {.mediumcode}\n```{r  eval = FALSE, echo = TRUE}\n    if (class(result) == \"list\"){ # whatever the successful class is\n      common$raster <- result\n    } else {\n      common$logger %>% writeLog(type = \"error\", result)\n    }\n```\n\n## Info and support\n\n- README at [https://simon-smart88.github.io/shinyscholar/index.html](https://simon-smart88.github.io/shinyscholar/index.html)\n- Bug reports and feature requests: [https://github.com/simon-smart88/shinyscholar/issues](https://github.com/simon-smart88/shinyscholar/issues)\n- Any other questions: [simon.smart@cantab.net](mailto:simon.smart@cantab.net)\n\n## Acknowledgments\n\n::: columns\n::: {.column width=\"50%\"}\n\n- [Tim Lucas](https://timcdlucas.github.io/) for supervision\n- Wellcome for funding\n- Wallace developers \n:::\n\n::: {.column width=\"50%\"}\n<div> \n<img src=\"images/wellcome_logo.png\" width=\"300\" style = \"display: block;\">\n<img src=\"images/wallace_logo.png\" width=\"300\" style = \"display: block;\">\n</div>\n:::\n:::","srcMarkdownNoYaml":"\n\n## Overview\n\n-   Use of Shiny in academia\n-   How Shinyscholar helps to avoid common problems\n-   How to use `create_template()` to make an app\n-   How to develop modules\n\n::: {.fragment .fade-in}\n-   Please ask questions!\n:::\n\n## About me\n\n-   Background in plant sciences and agricultural science\n-   Software developer in the Department of Population Health Sciences at the University of Leicester with Tim Lucas\n-   Latecomer to R, starting in 2018\n-   Quickly fell in love with Shiny\n\n## {data-menu-title=\"About you\"}\n```{=html}\n<iframe width=\"100%\" height=\"100%\" src =\"https://wall.sli.do/event/hHaXgfyR5WUSp5R33BzT5W/?section=fd94117a-f537-4081-91a2-4ca9266d4e32\"></iframe>\n```\n\n## Tomvision\n<img src=\"images/tomvision.png\" class=\"centre_image\" >\n\n## Potato Yield Model Dashboard\n\n![](images/PYM_home.png)\n\n## Disagapp simplifies disaggregation regression [https://disagapp.le.ac.uk/](https://disagapp.le.ac.uk/)\n\n<img src=\"images/disagapp.png\" class=\"centre_image\" >\n\n## Shiny apps are becoming increasingly popular in academia\n\n::: columns\n::: {.column width=\"55%\"}\n-   The low barrier to entry makes Shiny popular\n-   Substantially increased apps as a method of dissemination\n-   \"shiny app\" or \"shiny application\" in Web of Science:\n:::\n\n::: {.column width=\"45%\"}\n```{r echo = FALSE, fig.height=10}\nyear <- c(2012, 2015:2023) \napps <- c(1, 4, 3, 12, 17, 39, 69, 75, 100, 134)\nmod <- lm(log(apps) ~ year)\n\npar(cex = 1.5, bg = '#e4fbf8')\nplot(year, apps, pch = 16, xlab = '', ylab = 'Number of publications')\nlines(seq(2012, 2023, 0.1), exp(predict(mod, data.frame(year = seq(2012, 2023, 0.1)))), col = 'blue')\n\n```\n:::\n:::\n\n::: {.notes}\n-   Easier to develop than using other web frameworks\n- Existing code can be adapted\n:::\n\n## The ease of development provides advantages and disadvantages\n\n-   Simple apps can be created in an afternoon\n-   Academics rarely have training in software development\n-   What started simple can quickly snowball to become very complex\n\n## Data flows through an analysis in discrete steps \n\n<img src=\"images/data_pipeline.svg\" class=\"centre_image\" >\n \n::: footer\n- Adapted from <a href=\"https://r4ds.hadley.nz/intro\" target=\"_blank\">Wickham (2022)</a>\n:::\n \n::: {.notes}\n-   Analytical apps have a flow of data through them\n-   Similar to an analysis, but we are providing options for the user to take their own particular path\n-   Distinguish between datavis apps and analysis apps\n:::\n\n## What characteristics should academic apps have?\n\n::: columns\n::: {.column width=\"50%\"}\n::: {.fragment .fade-in}\n-   Open\n:::\n::: {.fragment .fade-in}\n-   Attributable\n:::\n::: {.fragment .fade-in}\n-   Instructive\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment .fade-in}\n-   Reproducible\n:::\n::: {.fragment .fade-in}\n-   Reliable\n:::\n::: {.fragment .fade-in}\n-   Maintainable\n:::\n:::\n:::\n\n::: {.notes}\n- We are all familiar with the format and conventions of papers, but they weren't always like that. Should we aim to develop similar conventions for apps?\n\n- Open enables reuse and collaboration\n- Important to recognise developers of the software like authors of a paper\n- Users should be guided through inside of the application, not through watching videos or reading a guide \n- Analyses performed in the app should be reproducible outside of it\n- We should be confident that it functions as intended through the use of automated testing\n- Contracts are short, so it is important people unfamiliar with the code can understand what is happening.\n\n:::\n\n## There are many ways to structure shiny apps\n\n::: columns\n::: {.column width=\"20%\"}\n:::\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_1.svg)\n:::\n:::\n:::\n\n## There are many ways to structure shiny apps\n![](images/ROGUE_input.png)\n![](images/ROGUE_output.png)\n\n## There are many ways to structure shiny apps\n::: columns\n::: {.column width=\"20%\"}\n:::\n::: {.column width=\"15%\"}\n![](images/app_arch_1.svg)\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_2.svg)\n:::\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_3.svg)\n:::\n:::\n\n::: {.column width=\"15%\"}\n::: fragment\n![](images/app_arch_4.svg)\n:::\n:::\n:::\n\n## 50 apps published in 2023 were surveyed to determine current practices\n\n<img src=\"images/app_features.svg\" class=\"centre_image\" >\n\n::: {.notes}\n- Caveat: not all were analytical applications\n- i.e. whilst best practice, they are not used due to the difficulty of implementation\n:::\n\n## The size and structure of codebases varied substantially\n<img src=\"images/code_features.svg\" class=\"centre_image\" >\n\n## Other frameworks exist for making production quality shiny apps\n\n- `{rhino}` by Appsilon: dashboard-focused\n- `{golem}` by ThinkR: good but generic\n- `{teal}` by Insight Engineering / Roche: pharma-focused\n\n## `{shinymeta}` can also be used to create reproducible apps\n\n- Developed by Posit\n- Requires a lot of refactoring / unusual syntax\n- Unclear if it's suited to large apps\n\n```{r eval = FALSE, echo = TRUE }\nserver <- function(input, output) {\n  var <- metaReactive({\n    cars[[..(input$var)]]\n  })\n  output$Summary <- metaRender(renderPrint, {\n    summary(..(var()))\n  })\n  output$code <- renderPrint({\n    expandChain(output$Summary())\n  })\n}\n```\n\n## Wallace is an app for modelling species distributions\n<img src=\"images/wallace.png\" class=\"centre_image\" >\n\n## Wallace is an app for modelling species distributions\n\n-   In development since 2015 with two major releases\n-   Feature-rich with many ideal characteristics:\n\n::: columns\n::: {.column width=\"50%\"}\n-   Error messages\n-   Logging\n-   Save and load\n:::\n::: {.column width=\"50%\"}\n-   Reproducible\n-   Cites packages used\n:::\n:::\n\n::: footer\n- Kass *et al.* (2018) <a href=\"https://doi.org/10.1111/2041-210X.12945\" target=\"_blank\">DOI: 10.1111/2041-210X.12945</a>\n- Kass *et al.* (2022) <a href=\"https://doi.org/10.1111/ecog.06547\" target=\"_blank\">DOI: 10.1111/ecog.06547</a>\n:::\n\n## Wallace provided the foundation to create shinyscholar\n\n-  Lots of useful features that are difficult to implement from scratch\n-  Removed all the modules\n-  Adapted files so they could be edited programmatically\n\n## Various new features have been added since {.mediumtext}\n\n- Updated UI\n- Viewing source code\n- Running async tasks\n- End-to-end testing with {shinytest2}\n- Simplified reproducibility\n- Long-term reproducibility via {renv}\n- Automated tedious coding\n\n## Installation\n\n- `install.packages(\"shinyscholar\")` installs all you need to create new apps\n- The package also includes an example app, which requires `install.packages(\"shinyscholar\", dependencies = TRUE)` to run\n\n## Shinyscholar enforces a strict structure\n\n-   Structured as a package\n-   Analyses are split into components and modules\n-   Each module calls a function\n-   Each module is reproduced by a markdown chunk\n-   Data is passed between modules through `common`\n\n## This structure has various advantages\n\n- Modules are self-contained\n- New modules slot in easily\n- Explicit for developers where code is located\n\n## Overview of the live demo\n\n- The package contains an example app\n- We'll create a similar app and copy some of the modules\n- Then we'll develop a new module and go through each of the steps to develop it\n\n## `create_template()` requires a dataframe of modules \n\n```{r eval = TRUE, echo = FALSE}\n\nmodules <- data.frame(\n  \"component\" = c(\"select\", \"select\", \"transform\", \"plot\", \"plot\"),\n  \"long_component\" = c(\"Select data\", \"Select data\", \"Transform data\", \"Plot data\", \"Plot data\"),\n  \"module\" = c(\"async\", \"query\", \"filter\", \"hist\", \"scatter\"),\n  \"long_module\" = c(\"Upload your own data\", \"Query a database to obtain data\", \"Filter the data\",\n                    \"Plot the data as a histogram\", \"Plot the data as a scatterplot\"),\n  \"map\" = c(TRUE, FALSE, TRUE, FALSE, FALSE),\n  \"result\" = c(FALSE, FALSE, TRUE, TRUE, TRUE),\n  \"rmd\" = c(TRUE, TRUE, TRUE, TRUE, TRUE),\n  \"save\" = c(TRUE, TRUE, TRUE, TRUE, TRUE),\n  \"download\" = c(FALSE, FALSE, TRUE, TRUE, TRUE),\n  \"async\" = c(TRUE, FALSE, FALSE, FALSE, FALSE))\n\n```\n\n```{r eval = TRUE, echo = FALSE}\nknitr::kable(modules, format = \"html\")\n```\n\n## Modules in disagapp\n<img src=\"images/disagg_modules_path.svg\" class=\"centre_image\" >\n\n## `common` is an object passed between modules \n\n- A shared environment for storing data\n- Avoids having to manually manage what data each module interacts with\n- Helps ensure consistent use of variable names\n- All set to `NULL` by default \n- `common$reset()` allows it to be reset\n\n## `common` in Disagapp {.smalltext}\n\n::: columns\n::: {.column width=\"33%\"}\n- `shape`\n- `response_name`\n- `agg`\n- `agg_prep`\n- `agg_prep_lores`\n- `covs`\n:::\n::: {.column width=\"33%\"}\n- `covs_prep`\n- `covs_prep_lores`\n- `covs_matrix`\n- `covs_summary`\n- `mesh`\n- `prep`\n:::\n::: {.column width=\"33%\"}\n- `fit`\n- `fit_plot`\n- `pred`\n- `transfer`\n- `map_layers`\n- `poly`\n:::\n:::\n\n\n## `create_template()` creates an empty app ðŸš€ {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\n\ncommon_objects = c(\"raster\", \"histogram\", \"scatter\")\n\nshinyscholar::create_template(\n  path = file.path(\"~\", \"Documents\"), name = \"SSdemo\", author = \"Simon Smart\",\n  include_map = TRUE, include_table = TRUE, include_code = TRUE, \n  common_objects = common_objects, modules = modules, install = TRUE)\n\nSSdemo::run_SSdemo()\n```\n\n\n## Structure of the app files\n\n```\nâ”œâ”€â”€ DESCRIPTION                                                 Define dependencies\nâ”œâ”€â”€ inst\nâ”‚   â””â”€â”€ shiny\nâ”‚       â”œâ”€â”€ common.R                                            Data objects shared between modules\nâ”‚       â”œâ”€â”€ global.R                                            Loads package and modules\nâ”‚       â”œâ”€â”€ ui_helpers.R                                        Functions to create module UI\nâ”‚       â”œâ”€â”€ server.R                                            App server\nâ”‚       â”œâ”€â”€ ui.R                                                App UI\nâ”‚       â”œâ”€â”€ modules\nâ”‚       â”‚   â”œâ”€â”€ core_code.R                                     Displays code\nâ”‚       â”‚   â”œâ”€â”€ core_intro.R                                    Produces introductory walkthrough\nâ”‚       â”‚   â”œâ”€â”€ core_load.R                                     Loads app\nâ”‚       â”‚   â”œâ”€â”€ core_mapping.R                                  Creates map\nâ”‚       â”‚   â”œâ”€â”€ core_save.R                                     Saves app\nâ”‚       â”‚   â”œâ”€â”€ select_async.md                                 Module guidance\nâ”‚       â”‚   â”œâ”€â”€ select_async.R                                  Module UI and server\nâ”‚       â”‚   â”œâ”€â”€ select_async.Rmd                                Reproduces the module\nâ”‚       â”‚   â”œâ”€â”€ select_async.yml                                Module configuration\nâ”‚       â”‚   â”œâ”€â”€ ... (repeated for other modules)\nâ”‚       â”œâ”€â”€ Rmd\nâ”‚       â”‚   â”œâ”€â”€ gtext_load.Rmd                                  Guidance text for each component\nâ”‚       â”‚   â”œâ”€â”€ gtext_plot.Rmd\nâ”‚       â”‚   â”œâ”€â”€ gtext_rep.Rmd\nâ”‚       â”‚   â”œâ”€â”€ references.Rmd                                  Template for rep_refPackages\nâ”‚       â”‚   â”œâ”€â”€ text_about.Rmd                                  Main panel on intro tab\nâ”‚       â”‚   â”œâ”€â”€ text_how_to_use.Rmd                             Detailed instructions\nâ”‚       â”‚   â”œâ”€â”€ text_intro_tab.Rmd                              Sidebar on intro tab\nâ”‚       â”‚   â”œâ”€â”€ text_loadsesh.Rmd                               Guidance for loading\nâ”‚       â”‚   â”œâ”€â”€ text_team.Rmd                                   Lists developers\nâ”‚       â”‚   â”œâ”€â”€ userReport_intro.Rmd                            Introduction to markdown\nâ”‚       â”‚   â””â”€â”€ userReport_module.Rmd\nâ”‚       â””â”€â”€ www\nâ”‚           â”œâ”€â”€ css\nâ”‚           â”‚   â””â”€â”€ styles.css\nâ”‚           â”œâ”€â”€ favicon.ico\nâ”‚           â”œâ”€â”€ js\nâ”‚           â”‚   â””â”€â”€ shinyjs-funcs.js\nâ”‚           â””â”€â”€ logo.png\nâ”œâ”€â”€ R\nâ”‚   â”œâ”€â”€ helper_functions.R                                      Various utility functions\nâ”‚   â”œâ”€â”€ run_demo.R                                              Function to run app\nâ”‚   â”œâ”€â”€ select_async_f.R                                        Function for each module\nâ”‚   â”œâ”€â”€ select_query_f.R\nâ”‚   â”œâ”€â”€ plot_histogram_f.R\nâ”‚   â””â”€â”€ plot_scatter_f.R\nâ””â”€â”€ tests\n    â””â”€â”€ testthat\n        â”œâ”€â”€ test-load_user.R                                    Tests for each module\n        â”œâ”€â”€ test-load_database.R\n        â”œâ”€â”€ test-plot_histogram.R\n        â””â”€â”€ test-plot_scatter.R\n\n```\n\n## Shiny modules split code into manageable chunks {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\nui <- fluidPage(\n  load_module_ui(\"load\"),\n  plot_module_ui(\"plot\")\n)\n\nserver <- function(input, output, session){\n  load_module_server(\"load\")\n  plot_module_server(\"plot\")\n}\n```\n\n## `input` and `output` IDs are *namespaced* {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\nnumericInput(\"number\") \nplotOutput(\"plot\") \n\nns <- NS(id)\nplotOutput(ns(\"plot\"))\nnumericInput(ns(\"number\"))\n```\n\n- When used inside a module with an id of `load`, `ns()` appends `load-` to the ID so `load-plot` and `load-number` are created\n\n## By default though there is a lot to manage:\n- Sourcing the functions\n- Calling the functions\n- Passing data between modules\n- Reactivity between modules\n\n::: {.fragment .fade-in}\n- Shinyscholar takes care of all of these!\n:::\n\n## Modules in shinyscholar have a broader definition and several files ðŸš€ {.verysmalltext}\n\n- In `R/`:\n    -   Function: `<component>_<module>_f.R`\n\n- In `inst/shiny/modules/`:\n    -   Shiny module: `<component>_<module>.R`\n    -   Rmarkdown: `<component>_<module>.Rmd`\n    -   Guidance: `<component>_<module>.md`\n    -   Configuration: `<component>_<module>.yml`\n\n- In `tests/:`\n    -   Tests: `test-<component>_<module>.R`\n\n## The logging system provides a flexible way to inform users {.mediumcode}\n\n- Messages can be sent to users via `common$logger |> writeLog()`\n- Either from inside the module function or the module server function\n\n```{r eval = FALSE, echo = TRUE}\nif (is.null(common$raster)) {\n  common$logger |> writeLog(type = \"error\", \"Please load a raster file\")\n  return()\n}\n```\n\n## The logging system provides a flexible way to inform users {.mediumtext}\n\n- When `type = \"info\" / \"warning\" / \"error\"` a `shinyalert::shinyalert()` modal is also displayed\n- `type = \"starting\" / \"complete\"` keep track of slow tasks\n- When `logger = NULL` inside a function, i.e. when used in the rmarkdown messages are passed to `message()`, `warning()` or `stop()` instead \n\n## Unusually, data is not reactive\n\n- Shiny is built to be reactive, but for large apps it can be difficult to control\n- Data in shinyscholar is not reactive \n- `{gargoyle}` is used instead to explicitly trigger reactivity\n\n## Gargoyle is used to trigger events\n\n- Each module's identifier can be used to trigger events\n- `init(<id>)` is called during app start up\n- `trigger(<id>)` is called when a module runs successfully\n- `watch(<id>)` is used inside any outputs to be generated / other code that needs to run\n\n## Module development workflow\n\n<img src=\"images/workflow.svg\" class=\"centre_image\" >\n\n## Data flow in shiny vs shinyscholar\n\n::: columns\n::: {.column width=\"50%\"}\n```{mermaid}\nflowchart TD\nA[Input in UI] --> |input$| B([Computation in server])\nB --> |output$| C(Output in UI)\n\nclass A sin\nclass B sser\nclass C sout\n```\n:::\n::: {.column width=\"50%\" .fragment .fade-in} \n```{mermaid}\nflowchart TD\nA[Input in UI] --> |input$| C([Functions])\nB[Existing data] --> |common$| C([Functions])\nC --> |common$| D([Store in common])\nD --> |output$| E(Output in Results)\n\nclass A sin\nclass B sin\nclass C sser\nclass D sser\nclass E sout\n```\n:::\n:::\n\n## Developing the module function\n\n- Functions split the business logic from the shiny logic and enable reproducibility\n- First of all develop the function in an rmarkdown file\n- Once it works, move it to the function file and document\n- Parameters should either be `common` objects or `input` values\n\n## Functions should be written defensively\n\n- Check that inputs are correct and log any errors\n- May be not always be necessary when used in the app but we're also creating user-facing functions used in the rmarkdown\n- Catch any other errors and fail gracefully instead of crashing the app\n\n## The `select_query()` function in the example app is most complex ðŸš€\n\n```{r echo=TRUE, eval=FALSE}\nselect_query <- function(poly, date, token, logger = NULL) {\n\n  check_suggests()\n\n  if (!(\"matrix\" %in% class(poly))){\n    logger |> writeLog(type = \"error\",\"poly must be a matrix\")\n    return()\n  }\n\n  if (!is.character(date) || is.na(as.Date(date, format = \"%Y-%m-%d\"))) {\n    logger |> writeLog(type = \"error\",\"date must be a string with the format YYYY-MM-DD\")\n    return()\n  }\n\n  if (nchar(token) < 200 || is.null(token)){\n    logger |> writeLog(type = \"error\", \"This function requires a NASA token - see the documentation\")\n    return()\n  }\n\n  # convert to terra object to calculate area and extent\n  terra_poly <- terra::vect(poly, crs = \"EPSG:4326\", type = \"polygons\")\n  area <- terra::expanse(terra_poly, unit = \"km\")\n  if (area > 1000000) {\n    logger |> writeLog(type = \"error\", paste0(\"Your selected area is too large (\",round(area,0),\" km2)\",\n                                              \" when the maximum is 1m km2. Please select a smaller area\"))\n    return()\n  }\n\n  bbox <- c(min(poly[,1]), max(poly[,2]), max(poly[,1]), min(poly[,2]))\n\n  search_url <- glue::glue(\"https://ladsweb.modaps.eosdis.nasa.gov/api/v2/content/archives?products=MCD15A2H&temporalRanges={date}&regions=[BBOX]W{bbox[1]}%20N{bbox[2]}%20E{bbox[3]}%20S{bbox[4]}&archiveSets=61\")\n  check <- check_url(search_url)\n\n  if (!is.null(check)){\n    image_req <- httr2::request(search_url ) |>\n                  httr2::req_auth_bearer_token(token) |>\n                  httr2::req_perform()\n\n    image_resp <- image_req |> httr2::resp_body_html()\n\n    image_links <- xml2::xml_find_all(image_resp, \"//a\")\n    image_urls <- xml2::xml_attr(image_links, \"href\")\n  } else {\n    logger |> writeLog(type = \"error\", \"The FAPAR API is currently offline\")\n    return()\n  }\n\n  # download and stitch together tiles\n  raster <- NULL\n  for (file in image_urls){\n    if (tools::file_ext(file) == \"hdf\"){\n      req <- httr2::request(file) |>\n        httr2::req_auth_bearer_token(token) |>\n        httr2::req_perform()\n\n      temp <- tempfile(fileext = \".hdf\")\n      writeBin(httr2::resp_body_raw(req), temp)\n\n      tile <- terra::rast(temp)$Fpar_500m\n      if (is.null(raster)){\n        raster <- tile\n      } else {\n        raster <- terra::merge(raster, tile)\n      }\n    }\n  }\n\n  if (is.null(raster)){\n    logger |> writeLog(type = \"error\", paste0(\"No data was found for your selected area. \",\n                                               \"This could be due to cloud coverage or because the area is not over land.\"))\n    return()\n  }\n\n  # reproject and crop\n  raster <- terra::project(raster, \"EPSG:4326\")\n  raster <- terra::crop(raster, terra_poly)\n\n  # count missing values and log accordingly\n  missing_values <- length(terra::values(raster)[terra::values(raster) > 1])\n  urban <- length(terra::values(raster)[terra::values(raster) == 2.5])\n  water <- length(terra::values(raster)[terra::values(raster) == 2.54])\n\n  if (missing_values == terra::ncell(raster)) {\n    logger |> writeLog(type = \"error\", paste0(\"No data was found for your selected area. \",\n                                               \"This could be due to cloud coverage or because the area is not over land.\"))\n    return()\n  }\n  if (missing_values > 0) {\n    message <- glue::glue(\"{missing_values} pixels were removed.\")\n    if (urban > 0) {\n      message <- paste(message, glue::glue(\"{urban} pixels were removed due to urban land use.\"), sep = \" \")\n    }\n    if (water > 0) {\n      message <- paste(message, glue::glue(\"{water} pixels were removed due to water coverage.\"), sep = \" \")\n    }\n    logger |> writeLog(message)\n  }\n\n  # remove missing values and rescale data to 0 - 100 %\n  raster <- terra::clamp(raster, upper = 1, value = FALSE) * 100\n\n  raster\n}\n```\n\n## Unit testing {.mediumcode} ðŸš€\n\n- Each module should have unit tests and end-to-end tests\n- Unit test tests that the module function behaves as you expect\n- End-to-end tests check that the whole module works\n\n```{r echo = TRUE, eval = FALSE}\ntest_that(\"Check select_user function works as expected\", {\n  result <- select_user()\n  expect_true(is.null(result))\n})\n```\n\n## The shiny module contains several functions {.mediumtext}\n\n- `<identifier>_module_ui()` - user inputs\n- `<identifier>_module_server()` - server function\n\n- Optionally:\n- `<identifier>_module_result()` - display outputs\n- `<identifier>_module_map()` - modify the map\n- `<identifier>_module_rmd()` - transfer data to rmarkdown\n\n## Only Input functions are included in the module UI {.mediumcode .mediumtext}\n\n- Input IDs need wrapping in `ns()`\n- Everything is wrapped in `tagList`\n\n```{r echo = TRUE, eval = FALSE}\nplot_hist_module_ui <- function(id) {\n  ns <- NS(id)\n  tagList(\n    selectInput(ns(\"bins\"), \"Number of bins\", choices = c(10, 20, 50, 100)),\n    selectInput(ns(\"pal\"), \"Colour palette\", choices = c(\"Greens\", \"YlOrRd\", \"Greys\", \"Blues\")),\n    actionButton(ns(\"run\"), \"Plot histogram\")\n  )\n}\n```\n\n## Input widgets are inserted to the sidebar \n\n<img src=\"images/input_sidebar.png\" >\n\n## The server contains an `observeEvent()` triggered by `input$run` {.mediumtext .smallheader}\n\n- Inputs are checked and any errors logged\n- Inputs are passed to the module function \n- Input values are stored in `common$meta`\n- Module function is called and results stored in `common`\n- Use `trigger()` to run anything that relies on the results\n- Use `show_map()` or `show_results()` to change the view\n\n## The server contains an `observeEvent()` triggered by `input$run` {.mediumcode .smallheader}\n\n```{r echo = TRUE, eval = FALSE}\n  observeEvent(input$run, {\n    # WARNING ####\n    if (is.null(common$raster)) {\n      common$logger |> writeLog(type = \"error\", \"Please load a raster file\")\n      return()\n    }\n    # FUNCTION CALL ####\n    raster_name <- c(common$meta$select_query$name, common$meta$select_async$name, common$meta$select_user$name)\n    histogram <- plot_hist(common$raster, as.numeric(input$bins), input$pal, raster_name, common$logger)\n    # LOAD INTO COMMON ####\n    common$histogram <- histogram\n    # METADATA ####\n    common$meta$plot_hist$bins <- as.numeric(input$bins)\n    common$meta$plot_hist$pal <- input$pal\n    common$meta$plot_hist$name <- raster_name\n    # TRIGGER ####\n    trigger(\"plot_hist\")\n    show_results(parent_session)\n    shinyjs::show(\"download\")\n  })\n```\n\n## Outputs are triggered when the module runs successfully {.mediumcode}\n\n```{r echo = TRUE, eval = FALSE}\noutput$hist <- renderPlot({\n  watch(\"plot_hist\")\n  req(common$histogram)\n  common$histogram()\n  })\n```\n\n## Outputs are inserted into the results tab {.mediumcode} ðŸš€\n\n- The visible results are determined by the module currently selected\n\n```{r echo = TRUE, eval = FALSE}\nplot_hist_module_result <- function(id) {\n  ns <- NS(id)\n  plotOutput(ns(\"hist\"))\n}\n```\n\n## Saving and loading \n\n- When the app is saved, `common` is saved to an `.Rds` \n- Each module's input values are stored in `common$state`\n- Distinct from those stored in `common$meta` which are only for modules that have been run\n\n## Saving and loading\n\n- Loading reloads data into `common`\n- Input values are restored from `common$state`\n- Module outputs are retriggered from `names(common$meta)`\n\n## The ability to save is also helpful during development\n\n- If working on a feature that relies on results from a slow step, it can be tedious to rerun each time a change is made\n- We can load `common` in outside shiny and use the exact data used in the app\n- Set `load_file_path` to point to a save file and it will be loaded automatically \n\n## `save_and_load()` takes care of tedious coding {.mediumcode} ðŸš€\n\n- Currently only default `{shiny}` inputs are supported\n\n```{r echo = TRUE, eval = FALSE}\nsave_and_load(\".\") # for all modules\nsave_and_load(\".\", module = \"component_module\") # for a single module\n\nnumericInput(ns(\"number\"), \"Enter a number\", value = 5)\n\nlist(number = input$number) # save\nupdateNumericInput(session, \"number\", state$number) # load\n```\n\n## Markdown files can be merged to replicate the analysis\n\n-   When a module is used an object becomes `TRUE`\n-   Input values are stored and *knitted* into the markdown\n-   Each chunk of the markdown calls the same function as the module in the app\n-   The chunks for used modules are combined into one `.Rmd` file\n\n## Input values are copied into the rmarkdown {.mediumcode}\n\n```{r eval = FALSE, echo = TRUE}\n#```{r, echo = {{select_query_knit}}, include = {{select_query_knit}}}\npoly <- {{select_query_poly}}\ntoken <- {{select_query_token}}\nras <- select_query(poly, {{select_query_date}}, token)\nraster_name <- {{select_query_name}}\n#```\n```\n\n## To create a reproducible chunk {.mediumcode} ðŸš€\n\n```{r eval = FALSE, echo = TRUE}\n#```{r}\npoly <- structure(c(-0.871582, -0.871582, 0.322266, 0.322266, -0.871582, \n                    42.136253, 43.421009, 43.421009, 42.136253, 42.136253), \n                  dim = c(5L, 2L), dimnames = list(    NULL, c(\"longitude\", \"latitude\")))\ntoken <- NULL\nraster <- select_query(poly, \"2024-10-09\", token)\nraster_name <- \"FAPAR\"\n#```\n```\n\n## You can also add data directly to the markdown {.mediumtext}\n\n- If the output of a module is a small dataframe (~ 1000 values) then you can insert the `common` object straight into the markdown\n- Especially useful if files are uploaded as that can't be reproduced automatically\n- Alternatively, download a `.zip` of data and load that in the markdown (example below)\n\n:::footer\n  - https://github.com/simon-smart88/disagapp/blob/main/inst/shiny/modules/rep_covs.R\n  - https://github.com/simon-smart88/disagapp/blob/main/inst/shiny/modules/rep_covs.Rmd\n  - https://github.com/simon-smart88/disagapp/blob/d7739ff034b2bf12760b54516a6d1f087e42b97c/inst/shiny/modules/rep_markdown.R#L77 \n\n:::\n\n## As for saving and loading, `metadata()` takes care of some of the tedium ðŸš€ {.mediumcode}\n\n- Unlike for `save_and_load()` this requires manual work afterwards and can therefore only be called once for each module\n\n```{r echo = TRUE, eval = FALSE}\nmetadata(\".\") # for all modules\nmetadata(\".\", module = \"component_module\") # for a single module\n\nnumericInput(ns(\"number\"), \"Enter a number\", value = 5)\n\ncommon$meta$component_module$number <- input$number # store\ncomponent_module_number <- common$meta$component_module$number # transfer to Rmd\n{{component_module_number}} # use in Rmd\n```\n\n## End-to-end tests ðŸš€ {.mediumcode}\n\n```{r echo = TRUE, eval = FALSE}\ntest_that(\"{shinytest2} recording: e2e_select_user\", {\n  app <- shinytest2::AppDriver$new(app_dir = system.file(\"shiny\", package = \"demo\"), name = \"e2e_select_user\")\n  app$set_inputs(tabs = \"select\")\n  app$set_inputs(selectSel = \"select_user\")\n  app$click(\"select_user-run\")\n  common <- app$get_value(export = \"common\")\n  expect_true(is.null(common$scatter))\n})\n```\n\n## Asynchronous modules\n\n- A major limitation of R and therefore Shiny is that it is single-threaded by default\n- When a slow operation is occurring apps become unresponsive to the user and anyone else connected to the same instance\n- `ExtendedTask` was added in Shiny v1.8.1 and enables tasks to run in the background\n\n## Slow running tasks can block the UI\n\n<div style=\"text-align: center;\">\n  <video style=\"width: 80%;\" loop muted data-autoplay>\n    <source src=\"images/async.webm\" type=\"video/webm\">\n  </video>\n</div>\n\n## Asynchronous modules\n\n- When `async = TRUE` for a module a different skeleton is used\n- The structure is different since starting the task and dealing with the results are separate\n- The number of currently running tasks is shown under the logger\n\n## The normal logger can't be accessed from inside async tasks {.mediumtext .mediumcode}\n \n- `asyncLog()` is similar to `writeLog()` but can be used inside async functions\n- Use `async = FALSE` as the last parameter instead of `logger = NULL` \n- `return(async %>% asyncLog(\"message))` sends errors back\n\n```{r  eval = FALSE, echo = TRUE}\n  if (!is.character(date) || is.na(as.Date(date, format = \"%Y-%m-%d\"))) {\n    return(async %>% asyncLog(type = \"error\", \"date must be a string with the format YYYY-MM-DD\"))\n  }\n```\n\n## We can listen for messages in the server and then pass to the logger {.mediumcode}\n```{r  eval = FALSE, echo = TRUE}\n    if (class(result) == \"list\"){ # whatever the successful class is\n      common$raster <- result\n    } else {\n      common$logger %>% writeLog(type = \"error\", result)\n    }\n```\n\n## Info and support\n\n- README at [https://simon-smart88.github.io/shinyscholar/index.html](https://simon-smart88.github.io/shinyscholar/index.html)\n- Bug reports and feature requests: [https://github.com/simon-smart88/shinyscholar/issues](https://github.com/simon-smart88/shinyscholar/issues)\n- Any other questions: [simon.smart@cantab.net](mailto:simon.smart@cantab.net)\n\n## Acknowledgments\n\n::: columns\n::: {.column width=\"50%\"}\n\n- [Tim Lucas](https://timcdlucas.github.io/) for supervision\n- Wellcome for funding\n- Wallace developers \n:::\n\n::: {.column width=\"50%\"}\n<div> \n<img src=\"images/wellcome_logo.png\" width=\"300\" style = \"display: block;\">\n<img src=\"images/wallace_logo.png\" width=\"300\" style = \"display: block;\">\n</div>\n:::\n:::"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","output-file":"shinyscholar_workshop.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.5.57","auto-stretch":true,"title":"Shinyscholar","subtitle":"A template for creating reproducible Shiny applications","author":"Simon Smart","date":"7 June 2025","date-format":"long","preloadIframes":false,"logo":"images/uol_logo.png","theme":["default","custom.scss"],"chalkboard":true,"width":1600,"height":900,"scale":true,"slideNumber":true}}},"projectFormats":[]}